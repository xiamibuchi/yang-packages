## 观察者模式和发布/订阅模式

### 观察者模式

观察者模式是使用一个 subject 目标对象维持一系列依赖于它的 observer 观察者对象，将有关状态的任何变更自动通知给这一系列观察者对象。当 subject 目标对象需要告诉观察者发生了什么事情时，它会向观察者对象们广播一个通知。

![Observer](https://user-gold-cdn.xitu.io/2019/5/13/16aae4f3899c11da?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

如上图所示：一个或多个观察者对目标对象的状态感兴趣时，可以将自己依附在目标对象上以便注册感兴趣的目标对象的状态变化，目标对象的状态发生改变就会发送一个通知消息，调用每个观察者的更新方法。如果观察者对目标对象的状态不感兴趣，也可以将自己从中分离。

### 发布/订阅模式

发布/订阅模式使用一个事件通道，这个通道介于订阅者和发布者之间，该设计模式允许代码定义应用程序的特定事件，这些事件可以传递自定义参数，自定义参数包含订阅者需要的信息，采用事件通道可以避免发布者和订阅者之间产生依赖关系。

![Pub/Sub](https://user-gold-cdn.xitu.io/2019/5/13/16aae4f3a1cf0bd2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

> 学生时期很长一段时间内用过 Redis 的发布/订阅机制，具体可查看[zigbee-door/zigbee-tcp](https://github.com/zigbee-door/zigbee-tcp)，但是惭愧的是没有好好阅读过这一块的源码。

### 两者的区别

观察者模式：允许观察者实例对象(订阅者)执行适当的事件处理程序来注册和接收目标实例对象(发布者)发出的通知（即在观察者实例对象上注册`update`方法），使订阅者和发布者之间产生了依赖关系，且没有事件通道。不存在封装约束的单一对象，目标对象和观察者对象必须合作才能维持约束。 观察者对象向订阅它们的对象发布其感兴趣的事件。通信只能是单向的。

发布/订阅模式：单一目标通常有很多观察者，有时一个目标的观察者是另一个观察者的目标。通信可以实现双向。该模式存在不稳定性，发布者无法感知订阅者的状态。

## 设计原则

### 开闭原则

一个软件实体应该是对扩展开放的，对修改关闭的。
